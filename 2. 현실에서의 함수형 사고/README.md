## 토니 피자에 오신 것을 환영합니다.

때는 2118년, 미래 사람들도 여전히 피자를 좋아한다. 하지만 이제는 로봇이 피자를 만들며 그 로봇은 자바스크립트로 프로그래밍 되어 있다.

피자가게 주인인 토니는 로봇에 함수형 사고를 많이 사용했다. 

**파트 1: 액션과 계산, 데이터**

토니는 요리 재료와 기타 필요 자원을 사용하는 코드를 액션으로 구분하고 나머지 코드는 계산으로 구분했다. 이 파트에서는 토니의 코드에서 액션과 계산, 데이터 각 분류에 해당하는 예를 살펴보고 코드에 적용한 **`계층형 설계 원칙`**이 어떤 것인지 알아보자.

**파트 2: 일급 추상**

가게 주방에는 많은 로봇이 함께 피자를 만들고 있다. 이것은 분산 시스템이라고 할 수 있다. 토니는 가끔 실패하는 분산 시스템을 이해하려고 **`타임라인 다이어그램`**을 사용했다. 토니는 여러 로봇이 협력할 수 있도록 함수를 인자로 받는 **`일급 함수`**를 사용했다. 그래서 더 많이 더 빨리 피자를 만들 수 있었다. 

## 파트 1: 액션과 계산 데이터

토니는 사업이 성장해 확장성 문제를 겪었다. 하지만 토니는 열심히 함수형 사고를 적용해서 어려움을 이겨냈다. 토니는 함수형 사고 중 가장 먼저 액션과 계산, 데이터를 구분하는 것부터 시작했다. 

### 1. 액션

액션은 호출 횟수와 시점에 의존하는 것으로 오븐이나 배달차 같은 자원과 요리 재료를 사용하는 것은 액션이다. 액션은 사용할 때 조심해야 한다.

예)

- 반죽 펴기
- 피자 배달
- 재료 주문

### 2. 계산

어떤 것을 결정하거나 계획하는 것은 계산이다. 계산은 실행해도 다른 것에 영향을 주지 않는다. 계산은 아무 때나 사용해도 주방이 엉망진창 될 걱정이 없기 때문에 토니는 계산을 좋아한다.

예)

- 조리법에 나온 것을 두 배로 만들기
- 쇼핑 목록 결정

### 3. 데이터

토니는 변경 불가능한(immutable)데이터를 가능한 많이 쓰려고 한다. 결제, 재고, 피자 조리법 같은 것이 데이터이다. 데이터는 유연하기 때문에 저장하거나 네트워크로 전송하는 등 다양하게 사용할 수 있다.

예)

- 고객 주문
- 영수증
- 조리법

→ 실제로 액션과 계산, 데이터라는 용어를 사용하지 않더라도 위와 같은 기준으로 나누는 것이 중요하다. 

## 변경 가능성에 따라 코드 나누기

### 계층화 설계 맛보기

피자 사업이 성장하면서 만든 소프트웨어도 사업에 맞춰 달라져야 했다. 토니는 코드를 변경할 때 드는 비용을 줄이기 위해 함수형 사고로 코드를 구성하면 좋다는 것을 알고 있었다.

먼저 변경 가능성에 따라 코드를 나눠보자. 위쪽으로 갈수록 자주 바뀌는 코드가 있고 아래쪽으로 갈수록 자주 바뀌지 않는 코드가 있는 것을 생각해보자.

1. 비즈니스 규칙
    - 이번 주 메뉴(주방)
        - 이번 주 특별 메뉴를 위한 조리법
    - 이번 주 사야할 것(창고)
        - 재료를 어디서 구입할지 결정
2. 도메인 규칙
    - 피자 만들기(주방)
        - 조리법 순서
    - 재료 목록(창고)
        - 재료 목록에 대한 동작
3. 기술 스택
    - 자바스크립트(주방)
        - 객체
        - 배열
    - 자바스크립트(창고)
        - 객체
        - 숫자

각 계층은 그 아래에 있는 계층을 기반으로 만들어진다. 그래서 각 계층에 있는 코드는 더 안정적인 기반 위에 작성할 수 있다. 이런 구조로 소프트웨어를 만들면 코드를 쉽게 변경할 수 있다. 가장 위에 있는 코드는 의존성이 거의 없기 때문에 쉽게 바꿀 수 있으며 아래에 있는 코드는 위에 있는 코드보다 의존성이 많아 바꾸기 어렵지만 자주 바뀌지 않는다.

함수형 프로그래머는 이 아키텍처 패턴이 계층을 만들기 때문에 **`계층형 설계`**라고 부른다. 계층형 설계는 일반적으로 비즈니스 규칙, 도메인 규칙, 기술 스택 계층으로 나눈다.

계층형 설계로 만든 코드는 테스트, 재사용, 유지보수가 쉽다.

## 파트 2: 일급 추상

### 주방을 자동화하기

토니의 주방에는 로봇이 혼자 일하고 있었기 때문에 얼마 지나지 않아 확장성 문제가 생겼다. 토니는 고객이 원하는 속도로 피자를 만들 수 없었다. 다음 **`타임라인 다이어그램`**은 로봇 한 대가 피자를 만들기 위한 액션들을 보여준다.

1. 주문 접수
2. 반죽 만들기
3. 반죽 펴기
4. 소스 만들기
5. 소스 뿌리기
6. 치즈 갈기
7. 치즈 뿌리기
8. 오븐에 넣기
9. 10분 기다리기
10. 서빙

타임라인 다어그램을 사용하면 액션이 시간 순서에 따라 어떻게 실행되는지 볼 수 있다. 액션은 실행 시점에 의존하기 때문에 실행 순서가 중요하다는 것을 잊지말자. 토니는 주방을 더 효율적으로 운영하기 위해 다이어그램을 고치려고 한다.

## 분산 시스템을 타임라인으로 시각화하기

현재 로봇 한 대로 피자를 만들고 있다. 좋은 피자를 만들고 있지만 고객의 요구를 맞출 만큼 빠르지 않다. 한대의 로봇이 일을 차례대로 하고 있기 때문이다. 여기서 토니는 피자 하나를 로봇 세 대가 만들면 더 빠를 것이라고 생각했다. 피자 만드는 작업을 반죽 만들기, 소스 만들기, 치즈 갈기 작업으로 나누고 로봇 세 대가 일을 동시에 하면 더 빨리 만들 수 있다고 생각했다.

여러 대의 로봇이 함께 일 하는 것은 **`분산 시스템`**을 의미한다. 분산 시스템에서 독립된 액션의 실행 순서는 어떻게 될지 모른다. 

로봇들은 각자 타임라인을 가지고 있다. 

1. 로봇 1 : 반죽 만들기
2. 로봇 2 : 치즈 갈기
3. 로봇 3 : 소스 만들기
    - 반죽 펴기
    - 소스 뿌리기
    - 치즈 뿌리기
    - 오븐에 넣기
    - 10분 기다리기
    - 서빙

이렇게 타임라인을 그리면 문제를 파악하는 데 도움이 되었지만 실행 순서가 섞이는 것은 어떻게 할 수 없다. 이렇게 장사한 토니는 엉뚱한 피자가 만들어질 가능성이 있다.

## 각각의 타임라인은 다른 순서로 실행된다.

기본적으로 타임라인은 서로 순서를 맞출 수 있는 기능이 없다. 다른 타임라인 작업이 끝날 때까지 기다리라는 표시가 없어 순서대로 다음 단계를 그냥 진행한다. 서로 다른 타임라인에 있는 액션 간 실행 순서는 보장할 수 없다. 위에 타임라인 대로 작업한다면 소스가 먼저 완성되고 반죽이 나중에 완성될 수도 있고 이 경우 소스를 만드는 로봇은 반죽이 나오기도 전에 반죽 펴는 작업을 시작한다. 또 치즈 가는 작업이 가장 마지막 작업이 될 수 있다. 이 경우 소스 만드는 로봇은 치즈 가는 작업이 끝나기 전에 치즈 뿌리는 작업을 하게 된다.

이 순서는 여섯 가지 방법으로 섞일 수 있다. 소스 만들기가 가장 마지막 순서에 와야 제대로 된 피자가 완성된다.

이처럼 **타임라인을 서로 맞추지 않은 분산 시스템은 예측 불가능한 순서로 실행된다.** 

## 어려운 경험을 통해 분산 시스템에 대해 배운 것

### 토니의 회고

순차적인 프로그램을 분산 시스템으로 바꾸는 것은 어렵다는 것을 알았다. 올바른 순서로 동작하는 프로그램을 만들려면 액션에 집중할 필요가 있다는 것도 알았다.

### 1. 기본적으로 타임라인은 서로 순서를 맞추지 않는다.

반죽이 준비되지 않았는데 다른 타임라인은 그냥 진행되었다. 타임라인은 서로 실행 순서를 맞춰야 한다.

### 2. 액션이 실행되는 시간은 중요하지 않는다.

일반적으로 소스 만드는 것이 제일 오래 걸리는 작업이지만 항상 그렇지는 않다. 그래서 각각 타임라인은 다른 타임라인의 순서와 관계 없이 만들어야 한다.

### 3. 드물지만 타이밍이 어긋나는 경우는 실제 일어난다.

테스트할 때는 문제가 없었지만 실제 서비스에서 문제가 생겼다. 타임라인은 항상 옳바른 결과를 보장해야 한다.

### 4. 타임라인 다이어그램으로 시스템의 문제를 알 수 있다.

다이어그램을 보고 치즈가 제시간에 준비되지 않을 수 있다는 것을 알았다. 시스템을 잘 이해하기 위해 타임라인 다이어그램을 계속 쓰기로 한다.

## 타임라인 커팅: 로봇이 서로를 기다릴 수 있게 하기

토니는 타임라인 **`커팅`**이라고 부른 기술을 쓰려고 한다. 타임라인 커팅은 여러 타임라인이 동시에 진행될 때 서로 순서를 맞추는 방법이다.

타임라인 커팅은 **`고차 동작**(high-order operation)`으로 구현한다. 여기서 고차 동작은 고차 함수로 만든 동작을 말한다. 각 타임라인은 독립적으로 동작하고 작업이 완료되면 다른 타임라인 끝나기를 기다리기 때문에 어떤 타임라인이 먼저 끝나도 괜찮다.

순서를 맞춘 로봇 세대

1. 로봇 1 : 반죽 만들기
2. 로봇 2 : 치즈 갈기
3. 로봇 3 : 소스 만들기

**cut**

---

- 반죽 펴기
- 소스 뿌리기
- 치즈 뿌리기
- 오븐에 넣기
- 10분 기다리기
- 서빙

cut부분으로 모든 작업이 끝날 때까지 진행하지 못하게 한다. 이렇게 타임라인의 시간을 맞추는 작업을 커팅이라고 부른다.

## 좋은 경험을 통해 타임라인에 대해 배운 것

### 1. 타임라인 커팅으로 서로 다른 작업들을 쉽게 이해할 수 있다.

타임라인에 컷을 그려 동시에 할 수 있는 재료 준비와 순서대로 해야 하는 피자 만들기를 분리했다. 타임라인 커팅으로 더 짧아진 타임라인을 실행 순서에 상관없이 이해할 수 있다.

### 2. 타임라인 다어그램을 사용하면 시간에 따라 진행하는 작업을 쉽게 이해할 수 있다.

타임라인 다이어그램을 이해했기 때문에 동작 방법에 대해 확실할 수 있다. 타임라인은 동시에 실행되는 분산 시스템을 시각화하기 좋다.

### 3. 타임라인 다이어그램은 유연하다.

타임라인을 보고 쉽게 코드로 옮길 수 이따. 타임라인 다어그램으로 동시에 진행되는 작업을 쉽게 모델링 할 수 있다.