### 중첩된 데이터(nested data)

→ 데이터 구조 안에 데이터 구조가 있는 경우 데이터가 중첩되었다고 말한다. 배열 안에 객체가 있다면 중첩된 데이터이다. 이런 경우 객체가 배열 안에 중첩되었다고 볼 수 있다.

→ 깊이 중첩되었다는 말은 중첩이 이어진다는 말이다. 어떤 객체가 객체 안에 또 다시 배열 안에 객체 안에 있는 것처럼 중첩은 계속 이어질 수 있다.

## 카피-온-라이트 원칙 세 단계

카피-온-라이트는 세 단계로 되어 있다. 각 단계를 구현하면 카피-온-라이트로 동작한다. 장바구니 전역변수를 변경하는 동작을 모두 카피-온-라이트로 바꾸면, 장바구니는 더 이상 변경되지 않는다. 따라서 불변 데이터로 동작한다.

아래 세 단계로 카피-온-라이트를 적용하면 불변성을 유지하면서 값을 바꿀 수 있다.

1. 복사본 만들기
2. 복사본 변경하기
3. 복사본 리턴하기

## 불변 데이터 구조를 읽는 것은 계산이다.

### 변경 가능한 데이터를 읽는 것은 액션이다.

변경 가능한 값을 읽을 때마다 다른 값을 읽을 수도 있다. 따라서 변경 가능한 데이터를 읽는 것은 액션이다.

### 쓰기는 데이터를 변경 가능한 구조로 만든다.

쓰기는 데이터를 바꾸기 때문에 데이터를 변경 가능한 구조로 만든다.

### 어떤 데이터에 쓰기가 없다면 데이터는 변경 불가능한 데이터이다.

쓰기를 모두 없앴다면 데이터는 생성 이후 바뀌지 않는다. 따라서 불변 데이터이다.

### 불변 데이터 구조를 읽는 것은 계산이다.

어떤 데이터를 불변형으로 만들었다면 그 데이터에 모든 읽기는 계산이다.

### 쓰기를 읽기로 바꾸면 코드에 계산이 많아진다.

데이터 구조를 불변형으로 만들수록 코드에 더 많은 계산이 생기고 액션은 줄어든다.

## 불변 데이터 구조는 충분히 빠르다.

일반적으로 불변 데이터 구조는 변경 가능한 데이터 구조보다 메모리를 더 많이 쓰고 느리다. 하지만 불변 데이터 구조를 사용하면서 대용량의 고성능 시스템을 구현하는 사례는 많다. 이런 사례를 바탕으로 불변 데이터도 충분히 빠르다는 것을 알 수 있다.

### 언제든 최적화 할 수 있다.

애플리케이션을 개발할 때 예상하기 힘든 병목 지점이 항상 있다. 그래서 성능 개선을 할 때는 보통 미리 최적화하지 말라고 한다. 불변 데이터 구조를 사용하고 속도가 느린 부분이 있다면 그때 최적화하자.

### 가비지 콜렉터는 매우 빠르다.

대부분의 언어는 가비지 콜렉터 성능 개선을 위해 꾸준히 연구해 왔다. 어떤 가비지 콜렉터는 한두 개의 시스템 명령어로 메모리를 비울 수 있을 만큼 최적화되어있다. 우리는 이것을 그냥 쓰면 된다.

### 생각보다 많이 복사하지 않는다.

데이터 구조의 최상위 단계만 복사하는 것을 얕은 복사라고 한다. 얕은 복사는 같은 메모리를 가리키는 참조에 대한 복사본을 만든다. 이것을 구조적 공유라고 한다.

### 함수형 프로그래밍 언어에는 빠른 구현체가 있다.

예시로는 직접 불변 데이터 구조를 만들었다. 하지만 어떤 함수형 프로그래밍 언어는 언어에서 불변 데이터 구조를 지원한다. 직접 만든 것보다 더 효율적으로 동작한다. 

## 객체에 대한 카피-온-라이트

배열과 같은 단계로 구현한다.

1. 복사본 만들기
2. 복사본 변경하기
3. 복사본 리턴하기

객체를 복사할 때는 `Object.assign()` 을 사용한다.

```jsx
var object = { a:1, b:2 };
var object_copy = Object.assign({}, object);
```

### 얕은 복사

→ 중첩 데이터에서 최상위 데이터 구조만 복사한다.